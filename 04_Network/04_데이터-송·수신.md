# 데이터 송신과 수신

DNS서버를 통해 입력된 `URL`의 `IP`주소를 받아왔다. 엑세스 대상이 웹이므로 앞서 말했던 것 처럼 OS의 HTTP프로토콜 스택에 송신의뢰를 해야한다. 

### 소켓

*Socket, socket, 소켓* 

- `Socket` : 라이브러리
- `socket`: Socket에 있는 함수
- `소켓`: 서버와 클라이언트를 연결하는 데이터통로의 입구(같은거)

브라우저에서 DNS에 IP주소를 조회했던것 처럼, 이번에도 Socket라이브러리의 함수들을 사용한다.

1. 소켓 생성

   서버와 통신을 하려면 데이터를 주고 받을 수 있는 연결 통로같은 것이 필요하다. 그리고 그 데이터연결통로의 입구를 *소켓*이라고 한다. 연결할 수 있는 서버라면, 서버측에는 이미 소켓이 있을것이다. 우리는 이 서버의 소켓에 데이터통로를 연결해야한다.

   방법은 간단하다. Sokect라이브러리에 있는 `socket()`을 호출하면 된다. `socket()`은 `Descriptor`라는 것을 반환하는데, 이는 생성된 소켓에대한 번호표 같은거라고 이해하자. 컴퓨터 내부에서는 단일 통신뿐만 아니라 2,3개 이상의 여러 통신이 이루어지고 있을테니 하나하나의 소켓을 식별해야하기 때문에 존재한다.

   > *socket()의 동작방법이 복잡하여 추후 알아보자. 지금은 소켓을 생성하고 `descriptor`를 반환하는 메소드라고 생각해두자*

   

2. 웹 소켓과 연결

   데이터통로의 양쪽 입구가 생겼으니 이제 연결해보자. 이 또한 Socket라이브러리를 사용하는데, `connect(descriptor, IP_address, port_number,...)` 메소드를 사용한다. 

   `descriptor`로 프로토콜 스택에 통지하여 서버와 연결할 소켓이 무엇인지 식별하고 연결한다.
   
   `IP address`는 서버의 주소를 알아야 하기 때문에 사용되는데, `port_number`도 필요하다
   
   `IP`주소로 어느 PC(서버)인지 알았다면, `port_number`는 그 PC(서버)의 어느 소켓인지를 식별하기 위하여 필요하다. `port_number`는 사용되는 어플리케이션마다 미리 결정된 값을 사용한다고 생각하자 (ex. Web: 80, Mail: 25)
   
   
   
3. 송신

   이제 URL을 바탕으로 만들어진 HTTP리퀘스트 메시지를 송신한다. 송신할 데이터를 메모리에 저장한 뒤, Socket라이브러리의 `write(descriptor, data, ...)`를 사용한다. 

   

4. 수신

   송신한 데이터를 바탕으로 처리되어 생성된 응답메시지를 받는 동작. 이 역시 Socket라이브러리의 `read(receive buffer,...)`를 사용하는데, 응답 메시지를 `receive buffer`로 지정한 메모리영역에 저장한다. 그 후 브라우저에 데이터를 건네준다.

   

5. 통신 종료

   Socket라이브러리의 `close(descriptor,...)`를 통해 descriptor에 해당하는 소켓이 말소시키며 연결이 종료된다. 

   순서는, 웹서버에서 응답메시지를 보내고 난뒤 `close()`를 하고, 이 정보가 클라이언트로도 전달이 되어 클라이언트측에서도 `close()`, -> 브라우저 `close()`



#### HTTP 프로토콜의 단점

지금까지 알아본 통신방법은 HTTP본래의 원리이다. HTTP 프로토콜은 HTML문서나 영상, 사진 데이터 하나하나마다 리퀘스트, 수신의 동작을 반복하여야 한다. 같은 서버에서 여러 데이터를 읽을 때에도 매번 연결하고 끊는 비효율적인 동작이 발생할 수 있다. HTTP 1.1버전에서는 한 번의 연결로 모든 리퀘스트와 응답을 주고 받고 연결을 끊는 동작을 할 수 있다. 


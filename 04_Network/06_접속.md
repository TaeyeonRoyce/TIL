# 접속



### 통신에서의 접속

> '접속' 이라는 말 보다는 '준비' 라는 단어가 더 어울리다고 할 수 있다. '접속' 이라는 용어는 기존 주류 기술이었던 전화에서 사용되던 용어를 적용하였기 때문이다. '전화번호를 다이얼링하여 상대와 접속한다', '통화한다',' 연결을 끊는다' 라는 3단계로 성립되어 있었기 때문에 '접속' 이라는 단어가 어색할 수 있다. 
>
> '준비'의 개념과 가깝다고 이해하면 좋을 것 같다

프로토콜 스택이 동작하면 최초로 소켓은 한 개 분량의 메모리를 확보하고, 그 영역에  `초기 상태`라는 정보를 기록을 저장한다. 초기 상태라는 정보외에는 아무것도 기록외어있지 않기 때문에 프로토콜 스택은 어디로 무엇을 통신해야하는 지 모른다. URL을 입력받은 브라우저는 통신 상대의 IP주소와 포트번호를 알고 있으며, 이를 프로토콜 스택에게 알려주는 것이 '접속'(준비) 단계 중 하나이다.

서버측에서도 소켓이 만들어졌다고 해서 통신에 대한 정보를 아는 것은 아니다. 클라이언트측에서 서버측에게 통신 동작의 개시를 전달하는 것도 '접속'(준비) 단계 중 하나이다.

'접속'은 통신 상대와의 사이에 제어 정보를 주고받아 소켓에 필요한 정보를 기록하고 데이터 송·수신이 가능한 상태로 만드는 것이다.

그리고, 데이터 송·수신 동작을 실행할 때 일시적으로 데이터 저장할 메모리 영역인 버퍼메모리의 확보도 접속의 한 단계이다.

> - 프로토콜 스택에게 통신 정보 알려주기
> - 서버측 소켓에도 통신 정보 알려주기
> - 버퍼 메모리 할당



## 접속 동작

Socket라이브러리의 `connect(<디스크립터>, <서버측의 IP주소와 포트번호>, ...)` 를 호출하며 시작한다. 인자로 넘겨준 서버측의 IP주소와 포트번호를 통해 TCP 담당 부분은 이를 참조하여 서버측의 TCP담당 부분과 제어 정보를 주고받는다.

	##### 	제어 정보의 교환

- 제어정보가 기록되어 있는 헤더를 만든다.
- 헤더 속에 포함되어 있는 송신처와 수신처, 포트번호를 통해 서버와 클라이언트의 소켓을 지정.
- 접속해야하는 소켓을 분명히 하기 위해 컨트롤 비트인 SYN을 1로 만든다.
- 만들어진 TCP헤더를 IP담당 부분에 건네주어 송신 의뢰를 하고, IP 담당 부분에서 서버측의 IP 담당 부분으로 패킷을 넘겨줌
- TCP헤더의 정보를 바탕으로 서버측 TCP담당 부분은 접속을 기다리는 소켓중에서 수신처 포트번호가 같은 소켓을 발견
- 이 소켓과 접속 진행한 뒤 응답을 보냄

응답은 클라이언트와 마찬가지로 송신처, 수신처, 포트번호가 담긴 TCP헤더를 만들지만, 이번에는 ACK라는 컨트롤 비트도 1로 만든다. 이는 패킷이 없어지는 경우를 대비하여 패킷의 도착을 확인하려고 하는 작업이라 한다.

응답으로 돌아온 패킷을 클라이언트측에서도 동일하게 IP담당을 경유하여  TCP담당 부분으로 도착한 뒤, SYN이 1임을 통해 접속 성공여부를 파악. 그 후 클라이언트 소켓에 접속완료와 함께 통신 제어 정보를 저장함. 또, 서버측에 통신 성공을 알리기 위해 ACK 비트를 1로 만든 TCP헤더를 반송한다.



## 커넥션

위와 같은 일련의 과정을 끝내면 클라이언트측의 소켓과 서버측의  소켓은 데이터를 송·수신할 수 있는 상태가 되었다. 파이프와 같은 것으로 소켓들이 연결되어 있다고 생각한다면, 이 파이프를 **커넥션**이라고 한다. (**세션** 이라고도 한다). `close()`가 호출되어 연결을 끊을 때 까지는 계속 존재한다.

이렇게 커넥션이 이루어지면 프로토콜 스택의 접속 동작이 끝나고, 호출했던 `connect()`의 실행도 끝나면서 어플리케이션을 제어 할 수 있게 된다.




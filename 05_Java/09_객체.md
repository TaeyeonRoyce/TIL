# 객체

기존의 프로그래밍 언어에 몇 가지 새로운 규칙을 추가하여 객체지향에 알맞는 설계를 하는 것.

코드의 **재사용성**, 코드의 **관리**, **신뢰성**의 증가를 기대할 수 있다.

객체에 대한 내용인 **클래스**, 그 클래스로 부터 만들어진 객체인 **인터페이스**가 있다.



### 인스턴스의 생성과 사용

클래스로 정의된 객체를 인스턴스화 하여 새로운 객체를 생성한다.

이때 생성된 객체는 클래스의 객체를 참조하는 참조변수이다.

`클래스 변수 = new 클래스` ,`Person me = new Person()`

> Person이라는 클래스를 참조하여 새로운 객체를 만들고(메모리에 할당하고), 그 객체를 me라는 참조변수를 통해 참조한다는 뜻

```JAVA
package playground;

public class playGround {
	static class Person{
    String name;
    int age;
    void upAge(){ ++age; }
    void changeName(String newName){ name = newName; }
  }
  public static void play(){
    Person me = new Person();
    me.name = "Royce";
    me.age = 23;
    System.out.println(me.name); // Royce
    System.out.println(me.age); //  23
    me.upAge();
    me.changeName("TaeYeon");
    System.out.println(me.name); // TaeYeon
    System.out.println(me.age); //  24
  }
}
```

위 코드 처럼, `Person` 이라는 class를 통해 객체에 대한 정보를 선언한다. `Person` 이라는 객체는 `name`, `age`, `upAge()`, `changeName() ` 라는 변수와 메소드를 가지고 있다.

`Person()` 객체를 만들고, `me` 라는 참조변수를 선언하여 생성된 객체를 참조한다. `me` 는 그 객체를 다룰 수 있는 리모콘 같은 역할을 하여 제어할 수 있다.

```java
Person me2 = me; // 참조변수 me를 복사
me2.changeName("Name Changed");
System.out.println(me2.name); //Name Changed
System.out.println(me.name);  //Name Changed
```

`me` 는 참조변수이기 때문에 `me2` 에는 `me`가 참조하는 값이 저장되고, `me2` 와 `me` 는 같은 `Person()` 을 참조하고 있기 때문에, 위와 같은 결과가 나오는 것이다.

참조변수는 인스턴스와 같은 타입이어야 한다. 

> **Person** a = new **Person**()



### 변수의 범위

```java
class playGround{
  int iv;
  static int cv;
  void method(){
    int lv;
  }
}
```

| 변수의 종류        | 선언 위치       | 생성시기                    |
| ------------------ | --------------- | --------------------------- |
| 클래스 변수 (cv)   | 클래스 영역     | 클래스가 메모리에 올라갈 때 |
| 인스턴스 변수 (iv) | 클래스 영역     | 인스턴스가 생성되었을 때    |
| 지역변수 (lv)      | 1 - 클래스 영역 | 변수 선언문이 수행되었을 때 |

같은 영역이지만 클래스 변수와 인스턴스 변수는 구분을 한다.

그 이유는 생성 시기에 따라 다르기 때문인데, 인스턴스 변수는 인스턴스가 생성될 때 마다 각각 다른 값들이 유지 되지만, 클래스 변수는 인스턴스의 생성과는 상관 없이 생성되기 때문에, 여러 인스턴스들이 생성되어도 같은 cv의 값을 참조한다. static(고정된)이라고 이해해도 괜찮을 것 같다.

```java
package playground;

public class playGround {
	static class Planet{
    String planetName;
    static int DAY_OF_YEAR = 365;
  }
  public static void play(){
    System.out.println(Planet.DAY_OF_YEAR); //365 --1
    Planet earth = new Planet();
    System.out.println(earth.DAY_OF_YEAR);  //365
    Planet mars = new Planet();
    mars.DAY_OF_YEAR = 687;

    System.out.println(earth.DAY_OF_YEAR);  //687 --2

  }
}
```

`--1`을 실행하면 `Planet` 이라는 객체가 생성되지도 않았는데 `DAY_OF_YEAR`를 참조할 수 있다.

또,  `--2` 를 보면, `earth` 와 `mars` 는 다른 객체를 참조하고 있지만, 이미 생성된 `DAY_OF_YEAR`는 공유하고 있다는 것을 알 수 있다. 그래서  `DAY_OF_YEAR` 와 같은 `cv`(클래스 변수)를 참조할 경우는 참조변수가 아닌 `--1` 처럼 클래스이름를 통해 접근하는 것이 권장된다.



### 메서드

구문
`반환타입 메서드이름 (타입 변수명, 타입 변수명, ...) { 수행될 코드 }`

```java
int add(int x, int y){
	int answer = x + y;
  return answer;
}
```

`return` 타입과 선언부에서 선언한 반환타입이 일치하여야 한다. 다르다면, 반환타입으로 형변환이 이루어져 반환 될 것이다.

```java
package playground;

public class playGround {
  static class MathPersonal{
          int add(int x, int y){
              int answer = x + y;
              return answer;
          };
      }
  public static void play(){
    MathPersonal math = new MathPersonal();
    int A = math.add(97, 2); //99
    int B = math.add('a', 2); //99 char 'a'가 int x로 변환되어 들어감
    System.out.println(A);
    System.out.println(B);
  }
}
```

반환 타입이 `void` 인 메소드는 `return` 이 없어야 한다.

메소드들은 `Call Stack` 이라는 공간에 호출된 메서드를 쌓는다. 그리고 그 메서드들에게 필요한 메모리 공간을 제공하고, 그 메소드가 종료되면 GC(garbage collector)를 통해 메모리가 반환되어 비어진다. 이때, 메소드들은 스택으로 쌓이다 보니 메소드들간의 관계 파악이 쉽다.



### 메소드의 매개변수

기본형 매개변수와 참조형 매개변수의 차이에 대해 알아 둘 필요가 있다.

기본형 매개변수는 읽기 전용이고,

참조형은 읽고 쓰기가 가능하다.

```java
package playground;

public class playGround {
    static class Data { int x; }
    static void changeDataRef(Data xRef){
        xRef.x = 1000;
        System.out.println(xRef.x);
    }
    static void changeDataValue(int xVal){
        xVal = 1000;
        System.out.println(xVal);
    }
    public static void play(){
        Data xRef = new Data();
        xRef.x = 10;
        System.out.println(xRef.x); // 10
        changeDataValue(xRef.x);    // 1000
        System.out.println(xRef.x); // 10    --1
        changeDataRef(xRef); 				// 1000
        System.out.println(xRef.x); // 1000  --2
    }
}

```

위 설명이 가능한 이유는 참조변수를 전해주면, 그 참조변수가 참조하고 있는 객체의 값을 변경하기 때문이다.



```java
package playground;

public class playGround {
    static  class Data { int x ;}
    static Data copy(Data d){
        Data tmp = new Data();
        tmp.x = d.x;
        return tmp;
    }
    public static void play(){
        Data d = new Data();
        d.x = 10;
        Data d2 = copy(d);
        System.out.println(d.x);  // 10
        System.out.println(d2.x); // 10
    }
  /*
  메소드에서 tmp가 참조하는 객체가 생성이 되고,
  그 객체를 참조하는 참조변수 tmp를 반환하여 d2에 저장하였다.
  이제 d2가 tmp가 참조했던 객체를 참조한다.
  */
}
```

참조변수를 반환하는 메소드 또한 `Obj val = new Obj()`의 원리를 잘 이해하면 쉽게 이해할 수 있다.


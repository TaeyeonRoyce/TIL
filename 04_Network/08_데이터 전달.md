# 데이터 송신

`connect()`메소드를 통해 클라이언트와 서버 소켓간의 커넥션이 생기면, `write()` 메소드를 실행한다.

이 메소드는 송신할 데이터를 프로토콜 스택으로 건네주고, 프로토콜 스택은 송신을 시작한다.

프로토콜 스택은 어플리케이션이 전해준 데이터를 송신용 버퍼 메모리에 저장해 둔다. 어플리케이션이나 OS의 종류, 상황에 따라 송신 의뢰에서 건네주는 데이터의 길이가 달라지는데, 매 순간 순간마다 데이터를 보낸 다면, 네트워크 이용 효율이 낮아지기 때문에 버퍼 메모리에 어느 정도 저장을 해두다가 송신을 시작한다.

*(트럭에 화물을 실을때마다 배송을 다녀오면 효율이 떨어지는 느낌...?)*

그 순간을 결정 짓는 요소는 데이터의 크기와 타이밍이 있다.

- 데이터 크기

  한 패킷에 저장 할 수 있는 최대의 데이터 크기를 **MTU**라고 하고, 이 MTU에서 헤더를 제거한 크기를 **MSS**라고 한다.

  데이터의 크기가 MSS에 가까운 길이에 이르기까지 저장하다가 송신 동작을 수행하여, 패킷의 효율을 최대한 활용하는 것이다.

- 타이밍

  메세지처럼 작지만 매 순간순간 통신이 필요한 경우에는 데이터 크기에 의존하여 패킷을 송신한다면 문제가 발생 할 수 있다.

  MSS에 가깝운 크기의 데이터가 저장될 때 까지 기다리면 송신 동작이 의도치 않게 지연될 수 도 있다.

어플리케이션은 이러한 경우를 대비해 데이터 송신에 대해 어느정도 옵션들을 정해 둔다.

그래서 이 둘을 절충하여 프로토콜 스택이 잘 판단하여야 한다. 절충안에 대해서는 규정이 존재하지 않아 OS의 종류와 버전에 따라 다르다.



## 확인

이렇게 송신한 데이터 잘 도착하였는지 확인하는 단계

TCP가 송신을 위해 분할된 패킷들마다 번호를 붙히고, 그 번호와 데이터의 크기를 같이 전달한다.

예를 들어, 100바이트 크기의 데이터를 10바이트마다 분할해서 송신한는 경우, `시퀀스 번호 : 1, 크기 :10`, `시퀀스 번호 : 11, 크기 :10`, `시퀀스 번호 : 21, 크기 :10`, ... 으로 보내고, 수신 측에서는 이 시퀀스 번호를 통해 데이터의 누락 부분을 확인 할 수 있는 것이다. 이 시퀀스 번호를 수신측에서는 TCP헤더의 ACK번호에 기록하여 송신측에 전달 하여 수신상황을 보내는 것이다.

실제로는 보안 문제상 초기값은 1이 아닌 난수로 시작한다. 데이터 수신의 확인을 위해선 송신과 수신측의 초기값이 일치되어야 하는데,  SYN이라는 제어 비트를 통해 그 초기값을 맞춘다.



### 작동

한 방향에서의 작동은 위와 같고, 반대의 경우는 역순으로 생각하면 된다.

이를 고려해서 데이터를 주고 받는 송신, 수신 작동에 대해 정리 해보면,

1. 송신측 에서 시퀀스 번호 (최초의 경우 초기값)을 전달
2. 수신측에서 송신측으로 ACK번호와 시퀀스 번호 초기값을 반환하여 확인

하는 동작을 반복하며 수행한다.



ACK 번호의 반환을 통해 데이터 전달을 확인 받는데, 만약 통신이 안되는 경우에는 어떻게 처리 될까?

우선, 송신한 데이터에 대응하는 ACK번호가 돌아오지 않으면 해당 패킷을 다시 보낸다. 이 과정을 통해 스스로 오류에 대해 회복을 취할 수 있다. TCP에 서 오류에 대해 회복을 취할 수 있기 때문에 다른 통신부분(버퍼, 라우터, 어플리케이션)은 회복조치를 하지 않는다.

돌아오지 않는 다는 것을 판단하는 시간은 패킷의 평균 왕복 시간을 바탕으로 조정된다.



### 윈도우 제어 방식

이러한 과정들은 1:1 대응하며 진행되는데, ACK번호가 돌아올때 까지 기다리는 동안 송신측은 가만히 있어야 한다.

윈도우 제어 방식을 통해 이러한 낭비를 줄일 수 있다. ACK번호가 돌아오지 않아도 연속해서 패킷을 보내는 방법인데, 이는 수신측의 능력을 초과하지 않도록 조절해야한다.



이렇게 서버측과 접속하고 데이터를 전달하면, 브라우저로 부터 요청된 송신 의뢰의 과정이 끝나게 된다. 하지만 브라우저는 송신 의뢰만 하고 끝나지 않는다. 돌아오는 응답 메시지를 받아야 하는데 이때 `read()`메소드를 호출한다. 프로토콜 스택에서는 데이터를 수신하여 수신 버퍼에 저장하고,  이 데이터를 어플리케이션이 지정한 메모리에 옮겨 기록한 뒤 제어를 어플리케이션에 돌려준다. 